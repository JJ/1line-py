<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>UIMP: pensamiento computacional con Python</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
	  <div class="reveal">
		  <div class="slides">
		    <section><h1>Pensamiento computacional en Python</h1></section>
		    
		    <section><pre><code>$ [sudo] pip install virtualenv</code></pre></section>
		    
		    <section><pre><code>apm install Repl
</code></pre></section>

<section><pre><code>>>> type(3)
type(3)
&lt;class 'int'>
>>> type(5.2)
type(5.2)
&lt;class 'float'>
</code></pre></section>

<section><pre><code>>>> 800//33
800//33
24
</code></pre></section>

<section><pre><code>>>> type(800/20)
type(800/20)
&lt;class 'float'>
>>> type(800//20)
type(800//20)
&lt;class 'int'>
>>> 800/20
800/20
40.0
>>> 800//20
800//20
40
</code></pre></section>

<section><pre><code>>>> type(333)
type(333)
&lt;class 'int'>
>>> type(333.)
type(333.)
&lt;class 'float'>
</code></pre></section>

<section><pre><code>>>> 5*(3**2 + 2**3)
5*(3**2 + 2**3)
85
</code></pre></section>

<section><pre><code>5*3**2 + 2**3
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicio:
> Usando `_` para recordar el valor anterior y ↑ para
> repetir la última orden en el intérprete, ir calculando una docena o
> más de valores de una progresión
> aritmética o geométrica.</textarea></section>

<section><pre><code>>>> len(_)
len(_)
17
</code></pre></section>

<section><pre><code>>>> _[0:3]
_[0:3]
'þor'
>>> _ + " y Loki el mentiroso ❄"
_ + " y Loki el mentiroso ❄"
'þor y Loki el mentiroso ❄'
</code></pre></section>

<section><pre><code>TypeError: unsupported operand type(s) for +: 'int' and 'str'
</code></pre></section>

<section><pre><code>>>> type(True)
type(True)
&lt;class 'bool'>
</code></pre></section>

<section><pre><code>not(3)
False
</code></pre></section>

<section><pre><code>not(None)
True
</code></pre></section>

<section><pre><code>3 and ""
''
</code></pre></section>

<section><pre><code>3.5 and "happy"
'happy'
</code></pre></section>

<section><pre><code>"" and 3
''
</code></pre></section>

<section><pre><code>[] or 45
45
</code></pre></section>

<section data-markdown>
	<textarea data-template>## Ejercicio
> Se dice que una fórmula es ["satisfacible"](https://es.wikipedia.org/wiki/Problema_de_satisfacibilidad_booleana) si es
>verdadera al menos para una combinación de valores. Con una fórmula
>de 3 variables, ¿cuantas combinaciones posibles de valores hay?
>Diseña una fórmula y pruébala sistemáticamente hasta que encuentres
>si es satisfacible o no. Altérala y vuelve a probar.</textarea>
</section>

<section><pre><code>3 < 3.5
True
</code></pre></section>

<section><pre><code>"alto" < "altos"
True
</code></pre></section>

<section><pre><code>"1" < "uno"
True
"menor" > "Mayor"
True
</code></pre></section>

<section><pre><code>"leño" < "lesa"
False
</code></pre></section>

<section> data-markdown>
	<textarea data-template>## Ejercicio
> Escribe una expresión
>que sea cierta (es decir, sea `True`) si un número está en un
>intervalo comprendido entre dos números naturales.</textarea>
</section>

<section><pre><code>"pepe" == "pepe"
True
1 == 0
False
</code></pre></section>

<section data-markdown>
	<textarea data-template>## Ejercicio
> Usando sólo los símbolos de mayor y menor y operadores
> lógicos (`and` y `or`), construir
> una expresión que sea equivalente a `!=`. Probar con diferentes
> valores que efectivamente es así. </textarea></section>

<section><pre><code>3 <= 3
True
</code></pre></section>

<section><pre><code>not True
False
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicio
> probar, usando todos los casos posibles,
> las
> [leyes de De Morgan](https://es.wikipedia.org/wiki/Leyes_de_De_Morgan). ¿Cuál
> sería el *modo Python* de expresar una expresión de ese
  estilo?</textarea></section>

<section>
  <section><h1>NAND = Not AND</h1>
    
    <code><pre>a NAND b == not (a and b)</pre></code>
    
  </section>
  <section data-markdown>
    <textarea data-template>## Ejercicio
> expresar `and`, `or` y `not` usando sólo NAND y probar
> exhaustivamente, usando valores de True y False, que es
  así.</textarea></section>
</section>

<section><h1>Pensamiento computacional</h1>
  <h2 class='fragment'>Descomposición</h2>
  <h2 class='fragment'>Reconocimiento de patrones</h2>
  <h2 class='fragment'>Abstracción</h2>
</section>

<section><pre><code>>>> 3+0.1j
3+0.1j
(3+0.1j)
>>> _**2
_**2
(8.99+0.6000000000000001j)
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicio
> Usar sólo números 5 para reconstruir los números del 0
> al 5. Si queda tiempo, hacerlo hasta el 10. </textarea></section>

<section data-markdown>
  <textarea data-template>## Ejercicio
>¿Para qué números se pueden usar más o menos los mismos
> patrones que para el 5? ¿Funciona con el 4? ¿Funciona con el 6?
> Específicamente, ¿con qué resultados hay que hacer pequeños cambios
> para que funcione?</textarea></section>


    <section><pre><code>>>>1+3.14j 
>>> _*(1+3.14j)
_*(1+3.14j)
(3.141592653589793+9.864600932271951j)
>>> _*(1+3.14j)
_*(1+3.14j)
(-27.833254273744135+19.729201864543903j)
...</code></pre></section>

<section><pre><code>33 & 1
1
30 & 1
0
</code></pre></section>

<section><pre><code>333 >> 1
166
888 << 1
1776
</code></pre></section>

<section><pre><code>2 << 36
137438953472
</code></pre></section>

<section><pre><code>32 ^ (1 << 3)
40
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicio

>Usando `xor`, comprobar si dos números enteros tienen el
> mismo signo. </textarea></section>

<section><pre><code>(lambda dato: dato*dato)(3+4j)
(-7+24j)
</code></pre></section>

<section><pre><code>["A1", 4+5j, lambda dato: dato*dato ]
['A1', (4+5j), <function <lambda> at 0x7fb4cb278a60>]
</code></pre></section>

<section><pre><code>["A1", 4+5j, lambda dato: dato*dato ].pop()
<function <lambda> at 0x7fb4cb278a60>
</code></pre></section>

<section><pre><code>["A1", 4+5j, lambda dato: dato*dato ][1]
(4+5j)
</code></pre></section>

<section><pre><code>["A1", 4+5j, lambda dato: dato*dato ][0:2]
['A1', (4+5j)]
</code></pre></section>

<section><pre><code>("A1", 4+5j, lambda dato: dato*dato )
('A1', (4+5j), <function <lambda> at 0x7faa8da8ee18>)
</code></pre></section>

<section><pre><code>list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre></section>

<section><pre><code>list(filter( lambda by11: by11//11 == by11/11, range(100) ))
[0, 11, 22, 33, 44, 55, 66, 77, 88, 99]
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicio
> Listar todos los números que sean potencia de dos entre
>los 1000 primeros números. ¿Se puede usar una técnica parecida para
>las potencias de tres? </textarea></section>

<section><pre><code>list(map( lambda num: num*"●", [3,15,2,7,33]))
['●●●', '●●●●●●●●●●●●●●●', '●●', '●●●●●●●',
'●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●']
</code></pre></section>

<section><pre><code>list(map(len,['●●●', '●●●●●●●●●●●●●●●', '●●', '●●●●●●●', '●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●'])
[3, 15, 2, 7, 33]
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicio
>*Representar* de forma gráfica (usando caracteres) el
> logaritmo de las 20 primeras potencias de dos. </textarea></section>

<section><pre><code>cifras_de = lambda numero: len(str(numero))
potencias_de_2 = map( lambda num: 2**num, range(20))
list(map( cifras_de, potencias_de_2 ))
</code></pre></section>

<section data-markdown>
  <textarea data-template>## Ejercicios

> Calcular los múltiplos de 3 entre los 100 primeros
> números naturales. ¿Qué tipo de estructura de datos podemos usar?
> ¿Cómo se averigua, con un test simple, si es un múltiplo de tres?
> ¿Se puede modificar la secuencia de operaciones anterior para
> detectar múltiplos de 9?</textarea></section>


<section><pre><code>type(potencias_de_2)
&lt;class 'map'>
</code></pre></section>

<section><pre><code>potencias_de_2=(2,4,8,16,32)
type(potencias_de_2)
&lt;class 'tuple'>
</code></pre></section>

<section><pre><code>potencias_de_2.insert(64)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'insert'
</code></pre></section>

<section><pre><code>potencias_de_2 = list( potencias_de_2)
potencias_de_2.insert(len(potencias_de_2),64)
</code></pre></section>

<section><pre><code>potencias_de_2
[2, 4, 8, 16, 32, 64]
</code></pre></section>

<section><pre><code>bash
python -c "print(list(map(lambda n: n/2 == n//2, range(1000))))"
</code></pre></section>

<section><pre><code>python -c "print('\n'.join(map(lambda n: str( n/2 == n//2 ), range(1000))))"
</code></pre></section>

<section><pre><code>python -c "es_par = lambda n: str(n/2 == n//2);print('\n'.join(map(es_par, range(1000))))"
</code></pre></section>

<section><pre><code>python -m timeit -s "print('\n'.join(map(lambda n: str( n/2 == n//2 ),
range(1000))))"
</code></pre></section>

<section><pre><code>100000000 loops, best of 3: 0.00571 usec per loop
</code></pre></section>

<section><pre><code>from timeit import timeit
</code></pre></section>

<section><pre><code>timeit(setup="map(lambda n: str( n/2 == n//2 ), range(1000))")
0.006306399000095553
timeit(setup="es_par = lambda n: str(n/2 == n//2);map(es_par, range(1000))")
0.006795324999984587
</code></pre></section>

<section><pre><code>timeit(setup="es_par = lambda n: str(n/2 == n//2);map(es_par, range(10000))")
0.006140023999250843
timeit(setup="map(lambda n: str( n/2 == n//2 ), range(10000))")
0.008905056998628424
</code></pre></section>

<section><pre><code>timeit(setup="es_par = lambda n: str(n^1 == 0);map(es_par, range(10000))")
0.006006274999890593
</code></pre></section>

<section><pre><code>>>> fibonacci = [1,1,2,3]
fibonacci = [1,1,2,3]
>>> fibonacci.append(5)
fibonacci.append(5)
>>> fibonacci.pop()
fibonacci.pop()
5
>>> fibonacci
fibonacci
[1, 1, 2, 3]
</code></pre></section>

<section><pre><code>suma_cifras = lambda n:  sum(map(int,list(str(n))))
def is_multiple_of_3(n): sum = suma_cifras(n); return is_multiple_of_3(sum) if (sum >= 10) else (True  if (sum==3) or (sum==9) else False)
</code></pre></section>

<section>
  <section data-markdown>
    <textarea data-template>## Ejercicios

> Usar una función recursiva para calcular el factorial
> de un número. ¿Habría alguna otra forma de hacerlo? ¿Cuál es más
> rápida para números pequeños? ¿Y para números más
> grandotes?</textarea></section>

  <section><h1>Sucesión marchosa</h1>

    <pre><code>def fib(n) {n<2 ? 1 : fib(n-1)+fib(n-2)}</code></pre>

    <aside class='notes'>Está en Groovy, pero la idea es compacta y
      está más o menos clara.</aside><
    /section>

  <section data-markdown>
    <textarea data-template>## Ejercicio
> Calcular los 20 primeros elementos de la sucesión de
> Fibonacci. ¿Hasta que número es más o menos razonable hacerlo de
> esta forma? </textarea></section>
</section>

<section><pre><code>juego = { 'jugador'   :'Johnny', 
         'mano'      : ['5♠','Q♣','8♥'], 
		 'estrategia': lambda mano: min(mano) } 
</code></pre></section>

<section><pre><code>juego.items()
dict_items([('jugador', 'Johnny'), ('mano', ['5♠', 'Q♣', '8♥']), ('estrategia', <function <lambda> at 0x7fcd3e298a60>)])
</code></pre></section>

<section><pre><code>def juega( mano ): return mano['estrategia'](mano['mano'])
</code></pre></section>

<section><pre><code>from random import random
juego_ricky = { 'jugador'   :'Ricky', 
	            'mano'      : ['3♠','4♣','A♥'], 
				'estrategia': lambda mano: mano[int(random()*len(mano))] }
				
juega(juego_ricky)
'3♠'
</code></pre></section>


<section><pre><code>mano_ricky= set( ['3♠','4♣','A♥'] )
</code></pre></section>

<section><pre><code>'3♠' in mano_ricky
True
</code></pre></section>

<section><pre><code>mano_johnny= set( ['7♣', '7♥', '7♦'] )
mano_johnny.intersection(mano_ricky)
set()
</code></pre></section>

<section><pre><code>mano_johnny - {'7♥'}
{'7♥', '7♣'}
</code></pre></section>

<section><pre><code>from random import choice
mano_johnny = mano_johnny | { choice(baraja) }
</code></pre></section>

<section><pre><code>mano_johnny = mano_johnny | { baraja.pop() }
</code></pre></section>

<section><pre><code>pip3 install bpython
</code></pre></section>

<section><pre><code>sudo pip3 install bpython
</code></pre></section>

<section><pre><code>pip3 install --user bpython
</code></pre></section>

<section><pre><code>export PATH=$PATH:~/.local/bin
</code></pre></section>

<section><pre><code>list(zip(sorted(['3♠','4♣','A♥']),sorted(['7♣', '7♥', '7♦'])))
[('3♠', '7♣'), ('4♣', '7♥'), ('A♥', '7♦')]
</code></pre></section>

<section><pre><code>from functools import reduce
def fact(n): return reduce( lambda prev,this: prev*this, range(1,n+1),1)
</code></pre></section>

<section><pre><code>def fib(n): return reduce( lambda prev,this: prev+ [prev[-2]+prev[-1]], rang
e(1,n+1), [1,1])
fib(12)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
</code></pre></section>

<section><pre><code>[Fraction(1,n) for n in range(1,100) if n % 2]
</code></pre></section>

<section><pre><code>[str(valor)+card for card in ["♠","♣","♥","♦"] 
    for valor in ['A','J','Q','K',2,3,4,5,6,7,8,9,10]]
</code></pre></section>

<section><pre><code>from random import random
aleatorios = [int(random()*10000) for _ in range(10000)]
def cuenta_pares( prev, this ): prev[this&1 ] += 1; return prev;
from functools import reduce
reduce( cuenta_pares, aleatorios, [0,0])
</code></pre></section>


			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
		 Reveal.initialize({
		   backgroundTransition: 'zoom',
		   transition: 'concave',
		   width: '95%',
		   slideNumber: true,
		   history: true,
		   dependencies: [
		     { src: 'plugin/markdown/marked.js' },
		     { src: 'plugin/markdown/markdown.js' },
		     { src: 'plugin/notes/notes.js', async: true },
		     { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
		 });
		</script>
	</body>
</html>
