# Datos compuestos

Lo interesante de los ordenadores es la capacidad que tienen para
representar cualquier tipo de dato, sea cual sea su estructura. No
todos los datos son "atómicos": un número, una ristra secuencial de
letras. En matemáticas existen estructuras, como las matrices y
vectores, que están compuestas de datos más simples, números
reales. Los árboles son estructuras de datos que son capaces de representar
cosas tan diversas como un árbol genealógico o la estructura de un
edificio. 

Todos los lenguajes de programación, o la mayoría, son capaces de
trabajar con estas estructuras, con una forma de escribirlas o
sintaxis particular y unas funciones que permiten modificarlas o
combinarlas. Empezaremos por las

## funciones,

que especifican qué secuencia de operaciones se debe aplicar a un
elemento determinado. En Python, las funciones son datos como
cualquier otro, número o cadena, y se pueden definir usando `lambda`. 

```Python
(lambda dato: dato*dato)(3+4j)
(-7+24j)
```

Esta función va a usar `dato` para referirse a los valores que se le
van a pasar a la función; tras los `:` especifica la operación que va
a realizar sobre el mismo, que es a la vez el valor que va a
devolver. En este caso, multiplicarlo por sí mismo. Los primeros
paréntesis, que, recordemos, sirven para agrupar operaciones, definen
esta operación sin nombre; los segundos paréntesis sirven para definir
el valor que se le va a pasar a la función definida, por el momento
sin nombre.

A los lenguajes que tienen, aparte de la posibilidad de definir
funciones como datos *de primera categoría*, otra serie de
características, se les llama lenguajes funcionales. Python no es, en
realidad, un lenguaje funcional, aunque sí permite, como se ve,
definir variables de esta forma, que además es muy similar a como se
hace en Ruby:

```Ruby
( -> ( dato ) { dato* dato }).call( 3+0.1i )
 => (8.99+0.6000000000000001i)
```

En este caso, `->` es el símbolo que se usa, en vez de `lambda`, para
indicar que se trata de una función; la variable implícita va rodeada
por paréntesis y en vez de usar `:` para separar los parámetros del
código, Ruby usa `{}` para indicar que se trata de un bloque de
código. Quizás
por
[aquello de "sencillo es mejor que anidado"](https://hipertextual.com/2011/02/zen-python). ¿Para
qué *anidar* usando bloques, cuando `:` es capaz de separar
perfectamente el código de la definición? ¿Para qué usar paréntesis
para agrupar los parámetros? Finalmente, ¿por qué usar `call` como se
hace en Ruby si con los paréntesis ya está claro que se trata de una
llamada de función?

Ruby, como casi todos los lenguajes modernos, también tiene elementos
funcionales, simplemente porque hoy en día es difícil trabajar en
entornos de *cloud* y similares sin tener un modelo de programación
que se parezca más al funcional que a otra cosa. Pero hay lenguajes
funcionales, como Clojure, donde esto se ve de forma más explícita:

```Clojure
user=> ((fn [zipi zape] (str zipi " " zape)) "þor" "es poderoso")
"þor es poderoso"
```

Todos los lenguajes funcionales, por herencia de Lisp, tienen muchos
paréntesis. Qué le vamos a hacer. La forma de trabajar también es
peculiar. No separan la función de los datos a los que se van a
aplicar, simplemente todo forma una *tupla* o agrupación donde el
primer elemento de la tupla se va aplicando al resto de los elementos
creando algo. Empecemos por la izquierda, después del segundo
paréntesis abierto. Definimos una tupla con tres elementos: `fn`,
`[zipi zape]` y un tercero que es a su vez una tupla con cuatro
elementos, `(str zipi " " zape)`. Este último define en sí la función
que se va aplicar a `zipi` y `zape`, que son simplemente *ranuras* o
*marcadores* que van a ser rellenos por lo que se le pase a la
función. Pero estos tres elementos, rodeados por paréntesis, son a su
vez el primer elemento de otra tupla que incluye como 2º y 3º
elemento `"þor"` y `"es poderoso"`. El intérprete de Clojure tomará
esos dos elementos que se insertarán en los *marcadores* `zipi` y
`zape` y devolverá el resultado en la siguiente línea, como se ve.

Igual que en los 90 el estilo de programación orientado a objetos se
acabó imponiendo como convención incluso en los lenguajes no
orientados a objetos como C, el estilo funcional es uno de los
paradigmas predominantes en esta década y posiblemente al principio de
la siguiente. Conviene conocer los lenguajes de programación
funcionales, e intentar funcionar de forma funcional (broma totalmente
intencionada) en el resto de los lenguajes. Incluso en Python. 

Una función es una estructura compleja porque incluye definiciones de
parámetros y también código. Pero

## vectores, listas y otras estructuras secuenciales

almacenan grupos de datos que pueden tener alguna relación
entre ellas. Por ejemplo

```Python
["A1", 4+5j, lambda dato: dato*dato ]
['A1', (4+5j), <function <lambda> at 0x7fb4cb278a60>]
```

La primera cadena puede ser una cadena única que sirva para
identificar, la segunda un valor inicial, y la tercera una función que
se va a aplicar repetidamente para obtener el resultado. Los tipos son
diferentes, tan diferentes como se pueda ser, pero a Python le da
igual. Los corchetes `[]` al principio y al final son los que indican
que se trata de una lista y las comas separan cada elemento del
siguiente. 

Como todo en Python,
las
[listas son objetos](https://docs.python.org/2/tutorial/datastructures.html). Python
es un lenguaje orientado a objetos, lo que viene a significar que
cuando se define algo usando una sintaxis determinada, lleva aparejada
una serie de operaciones que se pueden hacer con él. A esas
operaciones se puede acceder usando un `.` y el nombre de la
función. Por ejemplo, queremos extraer el último elemento de la lista:

```Python
["A1", 4+5j, lambda dato: dato*dato ].pop()
<function <lambda> at 0x7fb4cb278a60>
```

devuelve `<function <lambda> at 0x7fb4cb278a60>`, la función que está,
efectivamente, en la última posición. Podemos acceder a cualquiera de
los elementos de la lista también usando corchetes:

```Python
["A1", 4+5j, lambda dato: dato*dato ][1]
(4+5j)
```

o incluso a un rango de ellos:

```Python
["A1", 4+5j, lambda dato: dato*dato ][0:2]
['A1', (4+5j)]
```

Sin embargo, para lo que lo hemos planteado, almacenar operaciones y
valores iniciales, es posible que esta estructura no sea la más
adecuada. Una vez que se han establecido los valores, lo normal es que
no se alteren. Si algún valor inicial cambia, se puede crear un nuevo
terceto. Es decir, puede ser conveniente que los valores sean
inmutables, que no
cambien. Las
[*tuplas*](http://openbookproject.net/thinkcs/python/english3e/tuples.html) representan
este tipo de dato que va a ser inalterable a lo largo de su vida. 

```Python
("A1", 4+5j, lambda dato: dato*dato )
('A1', (4+5j), <function <lambda> at 0x7faa8da8ee18>)
```

Aparentemente es igual, pero su tipo es `tuple` en vez de `list`. Se
puede usar `[]` de la misma forma para acceder a elementos
particulares, pero `pop` no va a funcionar; simplemente no tiene ese
método porque una vez creada una tupla es inmutable, sólo se puede
procesar y generar alguna otra cantidad. Esta distinción entre
*tuplas* y *listas* es peculiar de Python, pero en casi todos los
lenguajes existen estructuras de datos inmutables o mutables. De
hecho, en algunos lenguajes funcionales como Clojure algunas
estructuras de datos similares, las *colecciones*, son inmutables por
omisión y hay que usar funciones para hacer versiones mutables. Esta
sería una lista equivalente a la anterior (salvo por la ausencia de
números complejos como dato base):

```Clojure
'("A1" 3 (fn [dato] (dato*dato)))
```

El `'` al principio hace que la lista no se evalúe, porque toda lista,
siempre, se evalúa en Clojure. Y, como se ha indicado, esa lista no se puede modificar, como
las tuplas de Python, sólo se le puede evaluar o pasar a una función
para que genere una nueva lista. 

En los dos lenguajes y en los dos casos indicados, las listas pueden
tener elementos homogéneos o heterogéneos. En muchos casos vamos a
trabajar con elementos del mismo tipo, numéricos por ejemplo. Siempre
que vayamos a

## procesar listas,

como la siguiente:
```
list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

que es una forma de indicarle a Python que queremos un rango de
valores que termina en el valor justo anterior al que le
pasamos, 10. Lo que ocurre es que un `range` es un objeto peculiar que
permite hacer ciertas cosas; nosotros necesitamos convertirlo en una
lista para poder trabajar con él fácilmente. Como generador de listas
de números, `range` es bastante flexible,
[pero es inmutable](http://www.mclibre.org/consultar/python/lecciones/python_range.html). Por
eso necesitamos convertirlo en un tipo mutable para poder trabajar con
él alterándolo *in situ*. 







