# Datos compuestos

Lo interesante de los ordenadores es la capacidad que tienen para
representar cualquier tipo de dato, sea cual sea su estructura. No
todos los datos son "atómicos": un número, una ristra secuencial de
letras. En matemáticas existen estructuras, como las matrices y
vectores, que están compuestas de datos más simples, números
reales. Los árboles son estructuras de datos que son capaces de representar
cosas tan diversas como un árbol genealógico o la estructura de un
edificio. 

Todos los lenguajes de programación, o la mayoría, son capaces de
trabajar con estas estructuras, con una forma de escribirlas o
sintaxis particular y unas funciones que permiten modificarlas o
combinarlas. Empezaremos por las

## funciones,

que especifican qué secuencia de operaciones se debe aplicar a un
elemento determinado. En Python, las funciones son datos como
cualquier otro, número o cadena, y se pueden definir usando `lambda`. 

```Python
(lambda dato: dato*dato)(3+4j)
(-7+24j)
```

Esta función va a usar `dato` para referirse a los valores que se le
van a pasar a la función; tras los `:` especifica la operación que va
a realizar sobre el mismo, que es a la vez el valor que va a
devolver. En este caso, multiplicarlo por sí mismo. Los primeros
paréntesis, que, recordemos, sirven para agrupar operaciones, definen
esta operación sin nombre; los segundos paréntesis sirven para definir
el valor que se le va a pasar a la función definida, por el momento
sin nombre.

A los lenguajes que tienen, aparte de la posibilidad de definir
funciones como datos *de primera categoría*, otra serie de
características, se les llama lenguajes funcionales. Python no es, en
realidad, un lenguaje funcional, aunque sí permite, como se ve,
definir variables de esta forma, que además es muy similar a como se
hace en Ruby:

```Ruby
( -> ( dato ) { dato* dato }).call( 3+0.1i )
 => (8.99+0.6000000000000001i)
```

En este caso, `->` es el símbolo que se usa, en vez de `lambda`, para
indicar que se trata de una función; la variable implícita va rodeada
por paréntesis y en vez de usar `:` para separar los parámetros del
código, Ruby usa `{}` para indicar que se trata de un bloque de
código. Quizás
por
[aquello de "sencillo es mejor que anidado"](https://hipertextual.com/2011/02/zen-python). ¿Para
qué *anidar* usando bloques, cuando `:` es capaz de separar
perfectamente el código de la definición? ¿Para qué usar paréntesis
para agrupar los parámetros? Finalmente, ¿por qué usar `call` como se
hace en Ruby si con los paréntesis ya está claro que se trata de una
llamada de función?

Ruby, como casi todos los lenguajes modernos, también tiene elementos
funcionales, simplemente porque hoy en día es difícil trabajar en
entornos de *cloud* y similares sin tener un modelo de programación
que se parezca más al funcional que a otra cosa. Pero hay lenguajes
funcionales, como Clojure, donde esto se ve de forma más explícita:

```Clojure
user=> ((fn [zipi zape] (str zipi " " zape)) "þor" "es poderoso")
"þor es poderoso"
```

Todos los lenguajes funcionales, por herencia de Lisp, tienen muchos
paréntesis. Qué le vamos a hacer. La forma de trabajar también es
peculiar. No separan la función de los datos a los que se van a
aplicar, simplemente todo forma una *tupla* o agrupación donde el
primer elemento de la tupla se va aplicando al resto de los elementos
creando algo. Empecemos por la izquierda, después del segundo
paréntesis abierto. Definimos una tupla con tres elementos: `fn`,
`[zipi zape]` y un tercero que es a su vez una tupla con cuatro
elementos, `(str zipi " " zape)`. Este último define en sí la función
que se va aplicar a `zipi` y `zape`, que son simplemente *ranuras* o
*marcadores* que van a ser rellenos por lo que se le pase a la
función. Pero estos tres elementos, rodeados por paréntesis, son a su
vez el primer elemento de otra tupla que incluye como 2º y 3º
elemento `"þor"` y `"es poderoso"`. El intérprete de Clojure tomará
esos dos elementos que se insertarán en los *marcadores* `zipi` y
`zape` y devolverá el resultado en la siguiente línea, como se ve.

Igual que en los 90 el estilo de programación orientado a objetos se
acabó imponiendo como convención incluso en los lenguajes no
orientados a objetos como C, el estilo funcional es uno de los
paradigmas predominantes en esta década y posiblemente al principio de
la siguiente. Conviene conocer los lenguajes de programación
funcionales, e intentar funcionar de forma funcional (broma totalmente
intencionada) en el resto de los lenguajes. Incluso en Python. 

## vectores, listas y otras estructuras secuenciales.

Las listas almacenan grupos de datos que pueden tener alguna relación
entre ellas. 

